# 2026.1.25

## 今日进度

今日目录结构如下

```markdown
TODO_API/
├── main.go
└── todos/（模拟测试数据，后期可改为数据库）
    └── data.go
```

第一天下载了gin框架，配置好环境，然后初步搭建了一个简单demo，熟悉了路由和基本web服务器，创建了简单的http服务器，添加了几个测试路由，学习了JSON响应。粗略构建了基础功能：实现 GET /todos（获取所有），实现 GET /todos/:id（获取单个），实现 POST /todos（创建），用 Postman 测试

## 今日问题

**包导入错误**

在新建目录`todos`时，在目录名前加入了一个空格，导致编译器无法识别`import "TODO_API/todos"`，使用`go mod tidy`下载所需要的依赖时或出现`go: TODO_API/ todos: malformed import path "TODO_API/ todos": invalid char`，对于Go工具链而言，我所导入的包属于无效路径，所以一直出现错误

解决方法：重命名`todos`目录，将前面的空格去掉后重新`go mod tidy && go run main.go`即可

**`BindJSON()`和 `shouldBindJSON()`**

```go
r.POST("/todos", func(c *gin.Context) {
		var content string
		if err := c.BindJSON(content); err != nil {
			c.JSON(400, gin.H{
				"code":    400,
				"message": "请求参数错误需要Content字段",
			})
			return
		}
		newTodo := todos.AddTodo(content)
		c.JSON(200, gin.H{
			"code":    200,
			"data":    newTodo,
			"message": "绑定成功",
		})
	})
```

最初我想通过这段代码完成发送post请求然后可以添加新的待办事项的功能，但是经过调试发现，发送的请求永远无法绑定成功，即新的待办事项永远添加不上，并且错误返回的信息也不是我自定义的信息

主要错误在于

- `BindJSON()`方法会自动返回 HTTP 400 错误响应，会自动中止请求并且调用`c.Abort()`

  ```go
  func createTodo(c *gin.Context) {
      var todo Todo
      if err := c.BindJSON(&todo); err != nil {
          // ❌ 这里不会执行！
          // BindJSON 内部已调用 c.AbortWithError(400, err)
          return
      }
      // 只有绑定成功才会执行到这里
  }
  ```

  正确的应该是使用`shouldBindJSON()`方法，其仅返回错误，不自动响应，并且不会自动中止请求，需要手动处理

- 使用`shouldBindJSON(content)`依然无法成功添加新的待办事项，因为`ShouldBindJSON`的参数必须是结构体指针，不能是基本类型（如 string）

正确代码如下

```go
//路由4：创建新的待办事项
	r.POST("/todos", func(c *gin.Context) {
		var requestBody struct {
			Content string `json:"content"`
		}
		if err := c.ShouldBindJSON(&requestBody); err != nil {
			c.JSON(400, gin.H{
				"code":    400,
				"message": "请求参数错误需要Content字段",
			})
			return
		}
		newTodo := todos.AddTodo(requestBody.Content)
		c.JSON(200, gin.H{
			"code":    200,
			"data":    newTodo,
			"message": "绑定成功",
		})
	})
```



# 2026.1.26

## 今日进度

今天重新学习了一下模板渲染，自定义模板函数，静态文件服务，控制器和中间件以及动态路由，重新熟悉了一下gin里面常用的一些方法。了解了goroutine和channel在gin框架中的使用技巧以及一些注意事项，了解如何通过goroutine和channel实现一个安全的异步日志中间件

## 今日问题

**`JSON XML Form`之间的区别是什么**

| 对比维度       | JSON             | XML              | Form Data      |
| -------------- | ---------------- | ---------------- | -------------- |
| **数据格式**   | 键值对           | 标签树           | 键值对（编码） |
| **数据结构**   | 对象、数组       | 树形结构         | 扁平键值对     |
| **文件支持**   | 需要 Base64 编码 | 需要 Base64 编码 | 原生支持       |
| **数据大小**   | 小（无冗余）     | 大（标签重复）   | 中等（有编码） |
| **解析难度**   | 简单（内置）     | 复杂（需解析器） | 简单           |
| **浏览器支持** | 原生 JSON.parse  | 需要 XML 解析器  | 原生支持       |
| **主流框架**   | 默认首选         | 旧系统兼容       | 表单上传       |
| **可读性**     | 优               | 良               | 差（编码后）   |
| **扩展性**     | 一般             | 强（可定义标签） | 差             |
| **安全性**     | 需防 XSS         | 需防 XXE         | 需防注入       |

- **JSON**：现代 Web 开发的标准，用就对了
- **Form Data**：表单提交和文件上传时用
- **XML**：遇到旧系统时了解一下就行

**中间件中使用goroutine为什么需要Context副本？**

核心在于：`Context`不是并发安全的。每个请求都有一个独立的`gin.Context`其中包含请求信息，响应信息，中间件索引，存储的键值对等，如果在 goroutine 中直接使用原始 Context，多个 goroutine 会同时修改同一个 Context，导致数据混乱。还有一点就是`goroutine`的周期可能会比请求的周期长，需要使用副本避免悬挂指针



# 2026.1.27

## 今日进度

初步学习了解MySQL数据库，认识了如何对数据库进行`CRUD`，了解了`Redis`和它的一些实际应用，完成了数据库的安装,认识了`yaml`，知道其与`json`的区别

## 今日问题

**MySQL数据库的存储位置是在硬盘里面，那么如果遇到短时间内需要快速读取大量数据的情况，MySQL的速度很显然跟不上，那应该怎么解决**

使用Redis，Redis是一个存储在内存中的键值数据库，它存储在内存里面，所以读取速度非常快，并且Redis是单线程，避免了上下文切换和资源竞争。所以Redis非常适合短时间需要读取大量数据的情况使用

**网站是如何记录我的登录状态，实现七天免登录**

服务器端生成一个session，然后设置session生命周期，即可实现



# 2026.1.28

## 今日进度

项目目录结构如下

```markdown
TODO_API/
├── cmd/
│   └── main.go                 # 程序入口
├── config/                     # 配置文件目录
├── internal/                   # 内部代码
│   └── app/
│       └── handler/           # 处理HTTP请求
├── pkg/                       # 可复用的公共代码
│   └── response/              # 统一响应格式
└── go.mod
```

今天学习了添加MySQL索引提高查询效率，事务与锁定，了解了`golang`的Viper配置管理库和Zap高性能日志库。创建了统一的响应格式`response.go`

## 今日问题

**为什么索引可以提高MySQL的查询效率**

因为索引的底层数据结构是`B+`树，B+树是多路平衡查找树，每个节点都有多个子节点，所有数据都在叶子节点，查找路径长度一致，叶子节点是链表连接，适合范围查询，树的高度也比较低，磁盘IO数量少。通过**空间换时间**，通过**预排序和高效数据结构**，将随机查找变为快速导航

**为什么做项目写代码之前先要分配好每一个目录，细致的划分每一个目录每一个文件**

因为先将目录划分清楚可以使项目有了晰的项目架构，代码按功能模块分离，易于维护和扩展，将项目工程化，先设计，后编码。这样将文件组织好之后，整个项目在多人开发时，清晰的架构让每个人知道代码放哪里并且很久之后回头看代码，还能快速找到要修改的地方，分离的模块可以单独测试，添加新功能时不需要重写大量代码。大大提升了团队协作性，可维护性，可测试与可拓展性



# 2026.1.29

## 今日进度

项目目录结构如下

```markdown
TODO_API/                     
├── cmd/                         # 命令行应用程序目录
│   └── main.go                  # 应用程序入口文件
├── config/                      # 配置文件目录
│   ├── config.dev.yaml          # 开发环境配置文件
│   ├── config.go                # 配置结构定义文件
│   ├── config.prod.yaml         # 生产环境配置文件
│   └── config.yaml              # 主配置文件
├── internal/                    # 内部包（外部不可导入）
│   └── app/                     # 应用程序代码
│       └── handler/             # HTTP 请求处理器
│           └── health.go        # 健康检查处理器
├── logs/                        # 日志文件目录
│   └── app.log                  # 应用程序日志文件
└── pkg/                         # 可复用包目录
    ├── logger/                  # 日志包
    │   └── logger.go            # 日志工具实现
    └── response/                # 响应包
        └── response.go          # 统一响应工具实现
```

今天初步配置了系统环境配置，尝试运用zap高性能日志库来对软件进行日志记录。当前项目可以支持多环境配置，结构化日志，便于调试和监控，开发生产环境相分离

## 今日问题

**什么是开发环境和生产环境**

| 方面         | 开发环境             | 生产环境           |
| ------------ | -------------------- | ------------------ |
| **目标**     | 快速开发、测试新功能 | 稳定运行、服务用户 |
| **使用者**   | 开发人员、测试人员   | 真实用户           |
| **数据**     | 测试数据、模拟数据   | 真实用户数据       |
| **性能要求** | 可接受较慢           | 必须高效           |
| **错误容忍** | 允许出错、崩溃       | 必须稳定、高可用   |
| **日志级别** | 详细调试信息         | 关键错误和警告     |
| **配置**     | 开发配置、调试模式   | 优化配置、生产模式 |



# 2026.1.30

## 今日进度

今天熟悉了一下GORM连接MySQL，了解如何对一个项目进行分层，每一层拥有不同的职责，层与层之间独立，互相关联但互不影响。了解如何去处理数据库连接操作耗时的问题，熟悉了连接池的原理以及其在golang中的使用。了解bcrypt哈希加密算法与其使用。

## 今日问题

**数据库连接池是什么？为什么需要连接池？**

每次数据库操作都需要：1.建立TCP连接（三次握手）2.数据库认证（用户名/密码验证）3.执行SQL 4.关闭连接（四次挥手）。但是步骤1-2和步骤4非常耗时！建立连接可能耗时100-300ms。所以我们可以预先建立一批连接，放在"池子"里，需要时直接取用。

连接池的工作原理如下

```markdown
启动应用 → 创建连接池（初始化N个连接）
          ↓
      连接空闲中（等待被使用）
          ↓
收到请求 → 从池中获取连接
          ↓
执行SQL → 使用连接
          ↓
完成请求 → 归还连接到池中
          ↓
应用关闭 → 关闭所有连接
```

**做一个项目为什么需要单独设计一个用户仓储层**

仓储模式的三层架构如下

```markdown
客户端请求
     ↓
控制器(Controller)   ← 处理HTTP请求
     ↓
服务层(Service)       ← 业务逻辑
     ↓
仓储层(Repository)    ← 数据访问
     ↓
数据库/外部服务
```

**用户仓储层就像银行的"保险库管理员"**，它把数据存取逻辑封装起来，让业务代码不用关心数据怎么存、存哪里、怎么取。使用仓储层之后，使整个项目职责分离，比如控制器就只处理HTTP请求，服务层就处理业务逻辑，仓储层就控制数据访问数据库。这样也方便单元测试，并且业务逻辑不直接和数据库相关，切换数据库只用切换实现业务代码不用改变。仓储层可以集中管理数据访问逻辑，服务层只需要调用仓储层接口即可



# 2026.1.31

## 今日进度

项目结构如下

```markdown
TODO_API/                           # 项目根目录
├── cmd/                            # 应用程序入口目录
│   └── main.go                     # 程序入口文件
├── config/                         # 配置文件目录
│   ├── config.go                   # 配置结构体定义
│   ├── config.yaml                 # 主配置文件
│   ├── config.dev.yaml             # 开发环境配置
│   └── config.prod.yaml            # 生产环境配置
├── internal/                       # 内部代码（外部不可导入）
│   ├── app/                        # 应用层
│   │   ├── dto/                    # 数据传输对象
│   │   │   ├── request/            # 请求 DTO
│   │   │   │   └── auth.go         # 认证请求结构
│   │   │   └── response/           # 响应 DTO
│   │   │       └── auth.go         # 认证响应结构
│   │   └── handler/                # HTTP 请求处理器
│   │       ├── auth.go             # 认证处理器
│   │       └── health.go           # 健康检查处理器
│   ├── domain/                     # 领域层
│   │   └── model/                  # 领域模型
│   │       ├── todo.go             # 待办事项模型
│   │       └── user.go             # 用户模型
│   ├── repository/                 # 数据访问层
│   │   └── user_repo.go            # 用户仓储实现
│   └── service/                    # 业务逻辑层
│       └── auth_service.go         # 认证服务
├── logs/                           # 日志文件目录
│   └── app.log                     # 应用程序日志
└── pkg/                            # 可复用公共包
    ├── database/                   # 数据库相关
    │   └── mysql.go                # MySQL 数据库连接
    ├── encryption/                 # 加密工具
    │   └── bcrypt.go               # 密码加密工具
    ├── logger/                     # 日志工具
    │   └── logger.go               # 日志记录器
    └── response/                   # 响应工具
        └── response.go             # 统一响应格式
```

今日对项目进行分层，并将每一层代码都实现了。定义了完整的数据模型User和Todo。完成了用户注册与登录的功能，并且可以对用户密码进行加密保存。使用postman完成对注册和登录功能的测试

## 今日问题

**`gin.Context`和`context.Context`有什么区别**

| 特性         | `context.Context`     | `gin.Context`                     |
| ------------ | --------------------- | --------------------------------- |
| **来源**     | Go标准库              | Gin框架                           |
| **主要目的** | 并发控制、值传递      | HTTP请求处理                      |
| **包含关系** | 被包含在gin.Context中 | 包含context.Context               |
| **使用场景** | 超时控制、取消操作    | Web请求处理、路由、渲染           |
| **数据存储** | `Value()`方法         | `Set()`/`Get()`方法 + 标准Value() |

**`srv.ListenAndServe()`和`g.Run(":"+port)`两种启动服务器的方法有什么区别**

| 对比维度     | **标准http.Server**              | **Gin框架**               |
| ------------ | -------------------------------- | ------------------------- |
| **框架依赖** | 使用标准库`net/http`             | 依赖Gin框架               |
| **启动方式** | `srv.ListenAndServe()`           | `g.Run(":"+port)`         |
| **控制粒度** | 更底层，可自定义更多参数         | 更简洁，Gin封装了默认配置 |
| **优雅关闭** | 更容易实现（有`Shutdown()`方法） | 需要额外处理              |
| **错误处理** | 明确区分正常关闭错误             | 统一处理所有错误          |

标准http.Server显示创建`http.Server`结构体，可自定义更多服务器参数（超时、TLS、读/写缓冲区等），明确检查`http.ErrServerClosed`，区分正常关闭，适合需要精细控制服务器配置的场景

g.Run()是Gin的快捷方法，内部会自动创建http.Server，代码更简洁，适合快速开发，使用Gin默认配置，定制性较低

技术细节对比

```go
// 标准http.Server的内部逻辑
srv.ListenAndServe()  →  net.Listen() + srv.Serve()

// Gin方式的内部逻辑
g.Run()  →  http.ListenAndServe()  →  net.Listen() + srv.Serve()
// 实际上Gin的Run方法内部就是：
// http.ListenAndServe(address, engine)
```



# 2026.2.2

## 今日进度

今天完成了JWT认证系统，定义了访问令牌+刷新令牌，完成了认证中间件和JWT令牌的生成和解析以及可以正确处理令牌过期或无效的错误

项目结构如下

```markdown
TODO_API/                     # 项目根目录
├── cmd/                      # 应用入口目录
│   └── main.go               # 主程序入口文件
├── config/                   # 配置文件目录
│   ├── config.go             # 配置结构体定义
│   ├── config.yaml           # 主配置文件
│   ├── config.dev.yaml       # 开发环境配置
│   └── config.prod.yaml      # 生产环境配置
├── internal/                 # 内部代码（不对外暴露）
│   ├── app/                  # 应用层（HTTP接口层）
│   │   ├── dto/              # 数据传输对象
│   │   │   ├── request/      # 请求DTO
│   │   │   │   └── auth.go   # 认证请求结构体
│   │   │   └── response/     # 响应DTO
│   │   │       └── auth.go   # 认证响应结构体
│   │   ├── handler/          # HTTP处理器（控制器）
│   │   │   ├── auth.go       # 认证处理器
│   │   │   └── health.go     # 健康检查处理器
│   │   └── middleware/       # 中间件
│   │       └── auth.go       # 认证中间件
│   ├── domain/               # 领域层（业务核心）
│   │   └── model/            # 领域模型（实体）
│   │       ├── todo.go       # 待办事项模型
│   │       ├── user.go       # 用户模型
│   │       └── tag.go        # 标签模型
│   ├── repository/           # 数据访问层
│   │   └── user_repo.go      # 用户数据访问实现
│   └── service/              # 业务逻辑层
│       └── auth_service.go   # 认证业务逻辑
├── pkg/                      # 公共工具包（可对外暴露）
│   ├── database/             # 数据库相关
│   │   └── mysql.go          # MySQL连接和操作
│   ├── encryption/           # 加密工具
│   │   └── bcrypt.go         # Bcrypt密码加密
│   ├── jwt/                  # JWT工具
│   │   └── jwt.go            # JWT生成和验证
│   ├── logger/               # 日志工具
│   │   └── logger.go         # 日志配置和输出
│   └── response/             # 响应工具
│       └── response.go       # 统一响应格式
└── logs/                     # 日志文件目录
    └── app.log               # 应用日志文件
```



## 今日问题

**双令牌机制是什么，有什么作用  **

双令牌机制使用**两种不同类型的令牌**：**Access Token（访问令牌）**：短期有效，用于API访问；**Refresh Token（刷新令牌）**：长期有效，用于获取新的Access Token

如果只使用一个七天的**长`Token`**，那么攻击者获得Token后可以长期使用，并且服务端无法主动使Token失效，用户权限变更后，旧Token仍然有效。如果只使用一个一小时的**短`Token`**，那么用户就需要频繁登录，体验会很差。双令牌机制使用一个短期**Access Token**用于获取API访问权限,一个长期**Refresh Token**用于获取新的**Access Token**

双令牌机制有如下优势：

 **安全性优势**

- **减少攻击窗口**：Access Token 有效期短，即使泄露影响有限
- **自动轮换**：定期刷新 Access Token，减少长期风险
- **可控性增强**：可以通过不颁发新 Refresh Token 来强制下线

**用户体验优势**

- **无感知刷新**：用户无需频繁登录
- **多设备管理**：可以分别管理每个设备的会话
- **安全通知**：检测到异常活动时可以主动使令牌失效

**性能优势**

- **减少数据库查询**：验证 JWT 签名即可，无需查询会话存储
- **水平扩展友好**：无状态设计，适合分布式部署



# 2026.2.4-2.6

## 今日进度

项目结构如下

```
TODO_API/                    # 项目根目录
├── cmd/
│   └── main.go              # 应用程序入口，初始化并启动服务
├── config/
│   ├── config.go            # 配置加载逻辑，解析yaml到结构体
│   ├── config.yaml          # 默认配置文件（通用配置）
│   ├── config.dev.yaml      # 开发环境配置文件
│   └── config.prod.yaml     # 生产环境配置文件
├── internal/                # 内部代码（不对外暴露）
│   └── app/
│       ├── dto/             # 数据传输对象
│       │   ├── request/     # 接收请求的结构体定义
│       │   │   ├── auth.go        # 登录/注册请求结构
│       │   │   ├── todo.go        # 待办事项请求结构（如创建、更新）
│       │   │   └── user.go        # 用户管理请求结构
│       │   └── response/    # 响应数据的结构体定义
│       │       ├── auth.go        # 认证响应（如令牌、用户信息）
│       │       └── todo.go        # 待办事项响应数据
│       ├── handler/         # HTTP请求处理器
│       │   ├── auth.go      # 认证相关路由处理（登录、注册、注销）
│       │   ├── health.go    # 健康检查接口
│       │   ├── todo.go      # 待办事项CRUD操作处理
│       │   └── user.go      # 用户信息管理处理
│       ├── middleware/      # 中间件
│       │   └── auth.go      # JWT认证中间件，保护需要登录的路由
│       ├── domain/          # 领域模型（业务核心）
│       │   └── model/       # 数据库映射的结构体
│       │       ├── todo.go        # 待办事项表结构
│       │       ├── todo_stats.go  # 待办事项统计视图结构
│       │       └── user.go        # 用户表结构
│       ├── repository/      # 数据持久层（数据库操作）
│       │   ├── todo_repo.go # 待办事项的数据库查询/更新方法
│       │   └── user_repo.go # 用户的数据库查询/更新方法
│       └── service/         # 业务逻辑层
│           ├── auth_service.go    # 认证逻辑（校验、令牌生成）
│           ├── todo_service.go    # 待办事项业务处理（含状态检查、统计）
│           └── user_service.go    # 用户业务处理（信息修改、密码更新）
├── logs/                    # 日志目录
│   └── app.log             # 应用程序运行日志（自动生成）
└── pkg/                    # 可复用的公共包
    ├── database/
    │   └── mysql.go        # MySQL数据库连接池初始化
    ├── encryption/
    │   └── bcrypt.go       # 密码加密与验证（bcrypt实现）
    ├── jwt/
    │   └── jwt.go          # JWT令牌生成与解析
    ├── logger/
    │   └── logger.go       # 日志器配置（如Zap或Logrus初始化）
    └── response/
        └── response.go     # 统一HTTP响应格式封装（成功/错误返回）
```

完成了Todo待办事项相关的功能，有了完整的Todo CRUD API，完善了用户认证和授权，分页和筛选功能，支持批量操作，有了完整的错误处理

## 今日问题

**为什么需要分页查询**

分页查询可以避免大数据量查询导致的系统瓶颈，分页查询比不分页查询**快10-1000倍**；提供清晰的信息组织和导航方式，用户对分页界面的**满意度提高300%**；防止单次查询耗尽系统资源，系统**崩溃率降低90%**

